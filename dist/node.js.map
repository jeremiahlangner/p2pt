{
  "version": 3,
  "sources": ["../src/p2pt.ts"],
  "sourcesContent": ["import WebSocketTracker from 'bittorrent-tracker/lib/client/websocket-tracker';\nimport { randombytes } from './util/randombytes';\nimport { toString, toBuffer } from './util/arraybuffer';\nimport EventEmitter from 'events';\nimport sha1 from 'simple-sha1';\nimport { Instance } from 'simple-peer';\n\nconst msgID = '^';\nconst max_length = 16000;\n\ninterface MsgData {\n  id: string,\n  msg: string,\n  o: 1 | null,\n  c: number,\n  last: boolean\n}\n\ninterface AnnounceOpts {\n  numwant: number,\n  uploaded: number,\n  downloaded: number\n}\n\ninterface Peer extends Instance {\n  id: string,\n  channelName: string,\n  connected: boolean,\n  respond: (msg: unknown) => Promise<unknown>,\n  destroy: () => void,\n  send: (msg: string) => void\n}\n\nclass P2PT extends EventEmitter {\n  announce: string[] = [];\n  trackers: { [key: string]: WebSocketTracker } = {};\n  peers: { [key: string]: { [key: string]: Peer } } = {};\n  responseWaiting: { [key: string]: { [key: string]: (value: unknown) => void } } = {};\n  msgChunks: { [key: string]: string[] } = {};\n  _identifier = '';\n\n  infoHash: string;\n  _infoHashBuffer: ArrayBuffer;\n  _infoHashBinary: string;\n\n  _peerIdBuffer: ArrayBuffer = randombytes(20);\n  _peerId: string = toString(this._peerIdBuffer);\n\n  set identifier(val: string) {\n    this._identifier = val;\n    this.infoHash = sha1.sync(val).toLowerCase();\n    this._infoHashBuffer = toBuffer(this.infoHash);\n  }\n\n  constructor(\n    announce: string[],\n    identifier: string\n  ) {\n    super();\n\n    this.announce = announce || this.announce;\n    this.identifier = identifier || this.identifier;\n  }\n\n  start() {\n    this.on('peer', (peer: Peer) => {\n      let newPeer = false;\n      if (!this.peers[peer.id]) {\n        newPeer = true;\n        this.peers[peer.id] = {};\n        this.responseWaiting[peer.id] = {};\n      }\n\n      peer.on('connect', () => {\n        this.peers[peer.id][peer.channelName] = peer;\n        if (newPeer) this.emit('peerconnect', peer);\n      });\n\n      peer.on('data', data => {\n        this.emit('data', peer, data);\n        data = data.toString();\n\n        if (data[0] === msgID) {\n          try {\n            data = JSON.parse(data.slice(1));\n            peer.respond = this._peerRespond(peer, data.id);\n\n            let msg = this._chunkHandler(data);\n            if (msg !== false) {\n              if (data.o) msg = JSON.parse(msg);\n\n              if (this.responseWaiting[peer.id][data.id]) {\n                this.responseWaiting[peer.id][data.id]([peer, msg]);\n                delete this.responseWaiting[peer.id][data.id];\n              } else {\n                this.emit('msg', peer, msg);\n              }\n              this._destroyChunks(data.id);\n            }\n          } catch (e) {\n            console.error(e);\n          }\n        }\n      });\n\n      peer.on('error', (err: Error) => {\n        this._removePeer(peer);\n        console.warn('Error in connection to peer:', err);\n      });\n\n      peer.on('close', () => {\n        this._removePeer(peer);\n        console.log(`Connection to ${peer.id} closed.`);\n      });\n    });\n\n    this.on('update', response => {\n      const tracker = this.trackers[this.announce.indexOf(response.announce)];\n      this.emit('trackerconnect', tracker, this.getTrackerStats());\n    });\n\n    this.on('warning', err => {\n      this.emit('trackerwarning', err, this.getTrackerStats());\n    });\n\n    this._fetchPeers();\n  }\n\n  addTracker(url: string) {\n    if (this.announce.indexOf(url) !== -1)\n      throw new Error('Tracker already added.');\n\n    const idx = this.announce.push(url);\n    this.trackers[idx] = new WebSocketTracker(this, url);\n    this.trackers[idx].announce(this._defaultAnnounceOpts());\n  }\n\n  removeTracker(url: string) {\n    const idx = this.announce.indexOf(url);\n    if (idx === -1) throw new Error('Tracker does not exist');\n\n    this.trackers[idx].peers = [];\n    this.trackers[idx].destroy();\n\n    delete this.trackers[idx];\n    delete this.announce[idx];\n  }\n\n  _removePeer(peer: Peer) {\n    if (!this.peers[peer.id]) return false;\n\n    delete this.peers[peer.id][peer.channelName];\n    if (Object.keys(this.peers[peer.id]).length === 0) {\n      this.emit('peerclose', peer);\n      delete this.responseWaiting[peer.id];\n      delete this.peers[peer.id];\n    }\n  }\n\n  send(peer: Peer, msg: unknown, msgId = '') {\n    return new Promise((resolve, reject) => {\n      const data: Partial<MsgData> = {\n        id: msgId || String(Math.floor(Math.random() * 100000 + 100000)),\n        msg: typeof msg === 'object' ? JSON.stringify(msg) : <string>msg,\n        o: typeof msg === 'object' ? 1 : null\n      };\n\n      try {\n        if (!peer.connected) {\n          for (const i in this.peers[peer.id]) {\n            peer = this.peers[peer.id][i];\n            if (peer.connected) break;\n          }\n        }\n        if (!this.responseWaiting[peer.id]) this.responseWaiting[peer.id] = {};\n        this.responseWaiting[peer.id][data.id] = resolve;\n      } catch (e) {\n        return reject(Error('Connection to peer closed' + e));\n      }\n\n      let chunks = 0;\n      let remaining = '';\n      while (data.msg.length > 0) {\n        data.c = chunks;\n        remaining = data.msg.slice(max_length);\n        data.msg = data.msg.slice(0, max_length);\n        if (!remaining) data.last = true;\n\n        peer.send(msgID + JSON.stringify(data));\n        data.msg = remaining;\n        chunks++;\n      }\n    });\n  }\n\n  requestMorePeers() {\n    return new Promise(resolve => {\n      for (const key in this.trackers) {\n        this.trackers[key].announce(this._defaultAnnounceOpts());\n      }\n      resolve(this.peers);\n    });\n  }\n\n  getTrackerStats() {\n    let connectedCount = 0;\n    for (const key in this.trackers) {\n      if (this.trackers[key].socket && this.trackers[key].socket.connect) {\n        connectedCount++;\n      }\n    }\n    return {\n      connected: connectedCount,\n      total: this.announce.length\n    };\n  }\n\n  destroy() {\n    for (const k in this.peers) {\n      for (const j in this.peers[k]) {\n        this.peers[k][j].destroy();\n      }\n    }\n    Object.keys(this.trackers).forEach(k => this.trackers[k].destroy());\n  }\n\n  _peerRespond(peer: Peer, msgId: string) {\n    return (msg: unknown) => this.send(peer, msg, msgId);\n  }\n\n  _chunkHandler(data: Partial<MsgData>) {\n    if (!this.msgChunks[data.id]) this.msgChunks[data.id] = [];\n    this.msgChunks[data.id][data.c] = data.msg;\n    if (data.last) return this.msgChunks[data.id].join('');\n    return false;\n  }\n\n  _destroyChunks(msgId: string) {\n    delete this.msgChunks[msgId];\n  }\n\n  _defaultAnnounceOpts(opts: Partial<AnnounceOpts> = {}) {\n    if (opts.numwant == null) opts.numwant = 50;\n    if (opts.uploaded == null) opts.uploaded = 0;\n    if (opts.downloaded == null) opts.downloaded = 0;\n    return opts;\n  }\n\n  _fetchPeers() {\n    for (const i in this.announce) {\n      this.trackers[i] = new WebSocketTracker(this, this.announce[i]);\n      this.trackers[i].announce(this._defaultAnnounceOpts());\n    }\n  }\n}\n\nexport { P2PT, Peer };\n"],
  "mappings": "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",
  "names": ["WebSocketTracker", "randombytes", "toString", "toBuffer", "EventEmitter", "sha1", "msgID", "max_length", "P2PT", "announce", "identifier", "val", "peer", "newPeer", "data", "msg", "e", "err", "response", "tracker", "url", "idx", "msgId", "resolve", "reject", "i", "chunks", "remaining", "key", "connectedCount", "k", "j", "opts"]
}
